\documentclass[]{thesis-ekf}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{defaults=hu-min}{magyar.ldf}
\usepackage[magyar]{babel}
\usepackage{mathtools,amssymb,amsthm,pdfpages,listings,multicol,enumitem}
\footnotestyle{rule=fourth}

\newtheorem{tetel}{Tétel}[chapter]
\theoremstyle{definition}
\newtheorem{definicio}[tetel]{Definíció}
\theoremstyle{remark}
\newtheorem{megjegyzes}[tetel]{Megjegyzés}
\input{arduinoLanguage.tex}
\input{csharpLanguage.tex}
\def\lstlistingname{kód}


\begin{document}

\institute{Matematikai és Informatikai Intézet}
\title{Szkenner megvalósítása egér szenzorral}
\author{Bodnár Máté\\Programtervező informatikus BSc}
\supervisor{Dr. Geda Gábor\\Egyetemi docens}
\city{Eger}
\date{2024}
\maketitle

\tableofcontents

\chapter*{Bevezetés}
\addcontentsline{toc}{chapter}{Bevezetés}
A digitalizálás egyre nagyobb szerepet játszik az életünkben, különösen a dokumentumok kezelésében és tárolásában, hiszen a sok ideig tárolt papír dokumentumok elveszhetnek vagy könnyen sérülhetnek.

Manapság a családi fotókat vagy régebbi képeket is célszerű digitalizálni, hogy tovább megmaradjon. A digitalizálással lehetőségünk nyílik arra is hogy rendszerezzünk hivatalos iratokat, így könnyebben tudunk majd hozzájuk férni és akár keresni is köztük. 

Bár számos szkenner van a piacon, viszont ezek drágák és nagy helyigényűek. Ezért egy saját készítésű szkenner jobban illeszkedik majd a mi igényeinkhez, valamint sokkal olcsóbb mint egy boltban vett. 

Ebben a projektben megmutatom, hogy lehet egy egérszenzort felhasználni hivatalos iratok vagy egyéb más papír alapú dokumentumok szkennelésére. A szenzor két sínnel vízszintesen és függőlegesen fog mozogni, és soronként készíti el a képkockákat. Ezután egy C\# alkalmazás feldolgozza azokat és kialakít belőlük egy nagy dokumentumot.

\chapter{Bevezető}

\section{Motiváció}
Az ötletem mögött több tényező is áll. Elsősorban szerettem volna egy olyan eszközt létrehozni, amely megfizethető alternatívát nyújt a drága szkennerekkel szemben. Az egérszenzorok könnyen beszerezhetők és viszonylag olcsók, ezért jó választásnak tűntek egy saját fejlesztésű szkennerhez. Ez különösen hasznos lehet olyan helyeken, ahol a költségek csökkentése nagyon fontos, például iskolákban vagy kisebb cégeknél.

Mindig is érdekelt, hogyan lehet egy meglévő egyszerű technológiát új és kreatív módon felhasználni. Az egérszenzorokat alapvetően mozgásérzékelésre tervezték, de ebben a projektben megszeretném mutatni, hogy dokumentumok szkennelésére is alkalmasak.

Emellett fontos számomra, hogy egy olyan eszközt alkossak, amelyet egy egyszerű felhasználó is használhat, otthon vagy akár a munkahelyén anélkül, hogy drága berendezésekre kellene költenie. 

Valamint kihívást látok ebben a projektben, hogy hogyan is tudom ezt megvalósítani. Izgalmas feladat az, hogy ötvözzem az informatikát az elektronikával. Ez nem csak a szakmai tudásomat fejleszti, hanem egy olyan eredményt ad, amelyre büszke lehetek.
\section{Célkitűzés}
A szakdolgozatom célja egy olyan szkenner létrehozása, amely egy egyszerű egérszenzort használ a dokumentumok fekete-fehér beolvasására. Az eszköz működésének alapja, hogy a szenzor monokróm felvételeket készít a dokumentumról, majd ezeket egy számítógépes programmal feldolgozom és összeállítom egy nagy dokumentummá. Mivel a szenzor csak egy 30\,x\,30-as képet rögzít így azt interpolációval felnövelem. Ezek az algoritmusok lehetővé teszik, hogy a képet megnöveljük kevés minőség vesztéssel. 

A dolgozat eredményeként egy egyszerű és költséghatékony szkennert szeretnék létrehozni, amely hasznos és megkönnyíti az emberek életét.
\chapter{Felhaszánlt technológiák}
Ebben a fejezetben a szakdolgozatomban használt technológiákról és azok előnyeiről, fogok beszámolni.
\section{Arduino}
\subsection{Arduino platform bemutatása}
Az Arduino\cite{arduino} egy nyílt forráskódú platform, amiket az elektronikai projektekhez találtak ki, majd bekerült az oktatásba is, oktatási céllal. Sokan használják egyszerűbb feladatok automatizálására vagy akár okos otthon rendszerek kialakítására. Ezek mellett manapság már az ipari alkalmazásuk sem ritka. A működéséhez szükség van egy mikrokontrollerre, valamint egy fejlesztő környezetre az Arduino IDE-re, amivel általában USB kábelen keresztül tudjuk átküldeni a programot a fizikai eszközre.
\begin{figure}[th!]
	\centering
	\includegraphics[width=0.9\linewidth]{ArduinoFamily}
	\caption[Arduino család néhány fajtája]{Arduino család néhány fajtája}
	\label{fig-arduinofamily}
\end{figure}
\subsection{Arduino Nano}
Elsősorban UNO-val terveztem elkészíteni ezt a projektet, de helyszűkében kénytelen voltam egy kisebb mikrokontroller után kutatni. Ekkor esett a választásom az Arduino Nano-ra. Az Arduino Nano az Arduino UNO kompaktabb változata, mely ugyanazt az ATmega328 mikrovezérlőt használja, így teljesítményében és képességeiben nagyon hasonló az UNO-hoz. A mikrovezérlő tartalmaz:
\begin{itemize}
	\item Processzort
	\item Memóriát
	\item Perifériákat:
	\begin{itemize}
		\item Időzítő áramkörök
		\item Analóg és digitális be- és kimenetek
		\item Kommunikációs interfészek (UART, SPI, I2C) és egyéb funkciók
	\end{itemize}
\end{itemize}

\begin{figure}[th!]
	\centering
	\includegraphics[width=0.4\linewidth]{ATMEGA328P-PU}
	\caption[ATmega328P]{ATmega328P mikrovezérlő}
	\label{fig:atmega328p-pu}
\end{figure}

Ezek segítségével tudunk szenzorjeleket mérni, nyomógombok vagy más beviteli eszközök állapotát beolvasni. A Nano áramköri lap szerepe az, hogy a mikrovezérlő lábait kivezesse. Így kényelmesebben és egyszerűbben rá tudjuk kötni a különböző eszközöket, amiket vezérelni szeretnénk, vagy értékeket beolvasni róluk. 

A mikrokontrollereken általában nem fut operációs rendszer, ezért minden erőforrást a feladatra összpontosít és egy garantált maximális idő alatt képes végre hajtani a feladatokat. 

Ahhoz hogy külső eszközöket és áramköröket rátudjunk csatlakoztatni, ismernünk kell a Nano lábkiosztását, amikre a kódból tudunk hivatkozni és vezérelni őket, áramköri lapon fel van tüntetve, hogy melyik lábat melyik számmal érjük el.  A Nano-n 14 digitális ki- és bemenet található (D0–D13), valamint 8 analóg bemenet (A0–A7), melyek közül az A0–A5 lábak digitális bemenetként és kimenetként is használhatók. A Nano-n található továbbá fix 3.3,V és 5,V-os kimeneti feszültségű láb is. Ez a lábkiosztás látható \aref{fig:arduino-nano-pinout}. számű ábrán.

\begin{figure}[th!]
	\centering
	\includegraphics[width=0.7\linewidth]{arduino-nano-pinout}
	\caption[Nano felépítés]{Arduino Nano lábkiosztása}
	\label{fig:arduino-nano-pinout}
\end{figure}

\subsection{Miért választottam az Arduino Nano-t?}
Szakdolgozatom során az Arduino Nano-t választottam, mivel több olyan előnye van, amelyek különösen fontosak a projektem szempontjából:

\begin{itemize}
	\item \textbf{1. Kompakt méret.} A Nano mérete kisebb, mint az UNO-é, így ideális választás volt, mivel helyszűkében voltam.
	\item \textbf{2. Egyszerű használat és támogatottság.} Az Arduino Nano széles körben elterjedt mikrokontroller, amelyhez könnyen elérhetőek könyvtárak és példakódok, ezzel egyszerűsítve a fejlesztést.
	\item \textbf{3. Megfelelő teljesítmény és elegendő számú I/O port.} A Nano szintén ATmega328 mikrovezérlőt használ, amely tökéletesen megfelel az ADNS-9800 szenzor kezelésére, a szenzor mozgatására, valamint az adatok továbbítására.
	\item \textbf{4. Megbízhatóság és stabilitás.} A stabil működés létfontosságú, mivel a projektem dokumentumok folyamatos szkennelését, adatgyűjtést és adatátvitelt igényel hosszabb ideig.
	\item \textbf{5. Költséghatékonyság.} Az Arduino Nano az egyik legkedvezőbb árú fejlesztőeszköz, amely tökéletesen kielégíti a projekt követelményeit.
	\item \textbf{6. Egyszerű programozhatóság és csatlakoztatás.} Az Arduino Nano könnyen programozható az Arduino IDE használatával, programokat egyszerűen USB-n keresztül tölthetünk fel rá.
\end{itemize}
\subsection{Az Arduino alkalmazási területei}
\begin{itemize}
	\item \textbf{Kezdő projektekhez.} Az Arduino Board-ok tökéletesek a kezdők számára akik az elektronikát és az informatikát szeretnék ötvözni. A fejlesztő környezetet egyszerű kezelni, valamint a könyvtárak és a példa kódok is nagyon sokat segítenek azoknak az embereknek akik elkezdenek érdeklődni az ilyen dolgok iránt.
	\item \textbf{Oktatási platform.} Könnyen kezelhetősége miatt szokták alkalmazni, hogy ezekkel az eszközökkel tanítsák meg az elektronika és az informatika működését.
	\item \textbf{Robotikában.} A nagy vállalatok vezetői is felfedezték ezt a technológiát, és gyakran Arduino Board-okat használnak a robotok megvalósításához és vezérléséhez.
	\item \textbf{Zene és művészet.} Az Arduino Board-okat szokták egyszerű hangszerek létrehozására is alkalmazni, vagy már meglévő hangszerekbe beépíteni elektronikus alkatrészként.
	\item \textbf{IoT - Internet of Things.} Legtöbb esetben okos otthon rendszerekbe szokták beépíteni, mert sok szenzort rá tudunk csatlakoztatni amikkel könnyen vezérelhetjük a saját otthonunkat. 
	\item \textbf{Viselhető eszközök. (Wearables)} Kompakt méretük miatt könnyen beépíthetőek ruhákba, akár ékszerekbe vagy más hordozható eszközökbe. Amelyekkel mozgásokra reagálhatunk mérhetünk testhőmérsékletet és még sok mást.
\end{itemize}
\section{Visual Studio}
A projekt szoftveres részét Visual Studio\cite{visual-studio} fejlesztői környezettel készítettem el, mert ez áll hozzám a legközelebb. Itt valósítottam meg az interpolációt a kép minőségvesztés nélküli növelését. Valamint a program irányító felületét is itt programoztam le. 
\section{Github}
A verziókövetéshez a Githubot\cite{github} használtam azon belül is a Github Desktop-ot, mellyel könnyen tudtam több platformon is dolgozni a projekten, valamint ha valamit elrontottam könnyen vissza tudtam állítani a projektet egy korábbi verzióra.
\chapter{Hardveres megvalósítás}
\section{ADNS-9800 szenzor}
Az általam készített szkennernek a lelke a kicsi és olcsó ADNS-9800 lézeres optikai érzékelő. Az eredeti felhasználási módja ennek az eszköznek az volt, hogy egerek mozgását kövessék. Ennek a szenzornak az a különlegessége, és azért volt megfelelő számomra, mivel úgy követi a mozgást, hogy folyamatosan képeket készít. Ezáltal fel tudtam használni a projektembe mint egy kis kamerát, valamint gyors képfeldolgozási képességgel rendelkezik, ezért alkalmas dokumentumok beolvasására. 
\subsection{Működése}
 Egy beépített lézer megvilágítja a szenzor alatt lévő felületet, majd a lencse készít egy képet. A beépített kis processzor dolgozza fel ezeket az adatokat, és számítja ki, hogy az eszköz milyen irányba mozdult el. 
\begin{figure}[th!]
	\centering
	\includegraphics[width=0.4\linewidth]{ADNS9800base}
	\caption[ADNS9800]{ADNS-9800 szenzor}
	\label{fig:adns9800base}
\end{figure}

Az általam választott szenzor már nyáklappal volt ellátva így azzal nem volt teendőm. Ezáltal egyszerűbb volt a bekötése és az elhelyezése is.

\begin{figure}[th!]
	\centering
	\includegraphics[width=0.5\linewidth]{ADNS9800}
	\caption[ADNS9800]{ADNS-9800 szenzor nyák lapra szerelve}
	\label{fig:adns9800}
\end{figure}

Csak egy problémám volt, hogy a nyáklappal szerelt verzió 3.3\,V-os logikai szinttel működött viszont az Arduino UNO 5\,V-os szinttel. Így be kellett szereznem egy két irányú logikai szintillesztő modult ami átalakította a 3,3\,V-os jelet 5\,V-ossá. Ehhez a projekthez egy 8 csatornás logikai szintillesztő modult használtam.

\begin{figure}[th!]
	\centering
	\includegraphics[width=0.6\linewidth]{szintilleszto}
	\caption[Logikai szintillesztő]{Két irányú logikai szintillesztő}
	\label{fig:szintilleszto}
\end{figure}
\pagebreak
\subsection{Adatok beolvasása}
Az adatok beolvasása közben a szenzor egy sorokból és egy oszlopokból álló képkockát készít, amely egy 30\,x\,30-as pixel rács. Ezáltal egy dokumentum szkennelése lehet akár több ezer képkocka is.
A működése a következő lépésekből áll:
\begin{enumerate}
	\item \textbf{Feltöltjük a firmware-t a szenzorra.} Erre azért van szükség, mert enélkül a szenzor csak egy hardveres érékelő, amely a lézerrel megvilágított felületről képeket készít. Ahhoz, hogy ezt az információt feldolgozza és továbbítsa szüksége van egy vezérlőprogramra, azaz firmware-re. Ezt a firmware-t minden bekapcsolás után fel kell tölteni, mert a szenzornak nincs állandó memóriája. A firmware feltöltését \aref{upload-firmware-code}. számú metódus végzi. A regiszterek megfelelő beállítása után a firmwaret soronként továbbítja  az SPI buszon keresztül a szenzornak. Ebben a metódusban fontos az időzítés hogy a szenzor helyesen értelmezze az adatokat.
	\begin{lstlisting}[language=Arduino,label=upload-firmware-code,caption=Firmware feltöltése]
		void adns_upload_firmware(){
			adns_write_reg(REG_Configuration_IV, 0x02);	
			adns_write_reg(REG_SROM_Enable, 0xd); 
			delay(10); 
			adns_write_reg(REG_SROM_Enable, 0x8); 
			adns_com_begin();
			SPI.transfer(REG_SROM_Load_Burst | 0x80); 
			delayMicroseconds(15);
			unsigned char c;
			for(int i = 0; i < firmware_length; i++){ 
				c = (unsigned char)pgm_read_byte(firmware_data + i);
				SPI.transfer(c);
				delayMicroseconds(15); 
			}
			adns_com_end();
		}
	\end{lstlisting}
	%%talán bele lehetne vinni a winforms-os elindítást
	\clearpage
	\item Majd a \textbf{sendFrame()} metódust meghívva készítünk egy képet a szenzorral. Amit egy nagy sebességű, full--duplex kommunikációs protokollal (Serial Peripheral Interface~--~SPI) kiolvasunk és eltároljuk, ahol a kommunikáció egy órajel vezérelt mechanizmussal működik. 
	\begin{lstlisting}[language=Arduino,label=sendFrame,caption=sendFrame metódus]
		void sendFrame() {
			adns_write_reg(REG_Power_Up_Reset, 0x5A);
			delay(50);
			adns_write_reg(REG_LASER_CTRL0, 0x00);
			adns_write_reg(REG_Frame_Capture,0x93);
			delayMicroseconds(120); 
			adns_write_reg(REG_Frame_Capture,0xc5);
			delayMicroseconds(120); 
			delay(1); 
			adns_com_begin(); 
			delayMicroseconds(100); 
			byte readys = 0;
			while(readys == 0){
				SPI.transfer(REG_Motion & 0x7f);
				delayMicroseconds(100); 
				readys = SPI.transfer(0); 
				readys = readys & 1;
				delayMicroseconds(20);
			}
			SPI.transfer(REG_Pixel_Burst & 0x7f); 
			delayMicroseconds(100); 
			Serial.print("FRAME:");
			for (int i = 0;i<900;i++){
				byte pixelValue = SPI.transfer(0);  
				Serial.print(pixelValue);
				Serial.print(" ");
			}
			delayMicroseconds(15); 
			adns_com_end();  
			delayMicroseconds(5); 
			Serial.println();
		}
	\end{lstlisting}
	\clearpage
	A metódus működése:
	\begin{enumerate}[label=\arabic*.]
		\item \textbf{Szenzornak kiadjuk, hogy készítsen egy képet.} Ekkor bele írjuk a megfelelő értéket a REG\_Frame\_Capture regiszterbe. A szenzor ekkor egy 30\,x\,30 pixeles képkockát olvas be.
		\item \textbf{Várunk amíg a szenzor elkészíti a képet.} Az Arduino egy ciklusban folyamatosan ellenőri a szenzor állapotát ezért amíg a szenzor nem jelzi, nem olvassuk ki az értéket.
		\item \textbf{A szenzor továbbítja a képkockát.} A Pixel Burst regiszteren keresztül történik a képkocka eljuttatása a szenzortól az Arduino-ig SPI kapcsolattal. Az SPI kapcsolat négy vezetéken keresztül történik:
		\begin{itemize}
			\item \textbf{MOSI }(Master Out, Slave In): Az adatok a mikrokontroller felől a szenzor felé mennek.
			\item \textbf{MISO }(Master In, Slave Out): Az adatok a szenzor felől mennek az Arduino felé.
			\item \textbf{SCLK }(Serial Clock): Az órajel, amelyet az Arduino generál.
			\item \textbf{CS }(Chip Select): Az adott szenzort választja ki a kommunikációhoz.
		\end{itemize}
		\item \textbf{Az Arduino továbbítja az adatokat a számítógépre.} Az adatok soros kommunikáción keresztül kerülnek a számítógépre ahol az feldolgozza ezeket. Minden képkocka ''FRAME:'' előtaggal kezdődik, hogy könnyebben elkülöníthetőek legyenek a képkockák.
	\end{enumerate}
\end{enumerate}
\subsection{Szenzor mozgása}
A szenzort két motor fogja mozgatni az egyik vízszintesen a másik függőlegesen. 
\section{Hardveres bekötés}
Már kész csak nem biztos hogy jó
\chapter{Szoftveres megvalósítás}

%%\section{Felhasznált algoritmusok/metódusok}
%%\section{Beolvasott értékek tárolása 2 dimenzós mátrixban}
%%adatszeerkezet amiben a beolvasott képet tároljuk
%%\section{Bikubik interpoláció}
%%\subsection{Működése}
%%Működésének alapjai, Matematikai leírása
%%\section{Mátrix átalakítása képpé}

\section{Az alap változók}
A feldolgozó szoftver Serial porton kapja meg az adatokat az Arduino-tól. Azokat átalakítja egy Bitmap képpé és elmenti a currentFrame változóba. Van két darab konstans értékem az egyik a beérkező képkocka szélessége a másik pedig a magassága, mivel a beérkező képkocka 30\,x\,30 pixel ezért ez a két érték 30. Van egy buffer-em ahol a Serial porton beérkező adatokat tárolom, erre azért van szükség mert nem biztos, hogy egy sor át tud jönni egyszerre. Valamint van egy Bicubic osztály példányom amivel a Bikubik interpolációt végzem. Végül van egy row és egy column változóm ami annak segítségére szolgál, hogy összerakjam a képkockákat egy nagy dokumentummá.
\begin{lstlisting}[language=CSharp]
private SerialPort serialPort;
private Bitmap currentFrame;
private const int FrameWidth = 30; 
private const int FrameHeight = 30; 
private StringBuilder buffer = new StringBuilder(); 
private Bicubic resizer = new Bicubic(FrameWidth, FrameHeight, 2);

int row = 0;
int column = 0;
\end{lstlisting}



\chapter*{Összegzés}
Tapasztalatok amiket szereztem a projekt megvalósítása közben
Tovabbfejlesztési gondolatok

színes vagy szürke képet szeretne beolvasni
soros porton küldok egy bitet hogy színes vagy szürke legyen a kép a studiobol
felbontásra vonatkozóan például  feles átfedéssel 
\addcontentsline{toc}{chapter}{Összegzés}
\chapter*{Források}
\begin{itemize}
	\item \ref{fig-arduinofamily}. ábra: \emph{\url{https://predictabledesigns.com/wp-content/uploads/2017/10/HeroImage.png}}
	\item \ref{fig:atmega328p-pu}. ábra: \emph{\url{https://techfun.hu/wp-content/uploads/2017/09/11.jpg}}
	\item \ref{fig-arduinoparts}. ábra: \emph{\url{https://www.inf.u-szeged.hu/~makan/tananyagok/wp-content/uploads/2020/07/ArduinoParts3-768x462.png}}
	\item \ref{fig:adns9800base}. ábra: \emph{\url{https://www.sicstock.com/cdn/shop/products/551554.jpg?v=1544514465}}
	\item \ref{fig:szintilleszto}. ábra: \emph{\url{https://www.elektrobot.hu/items/3607_1.webp}}
\end{itemize}

\begin{thebibliography}{2}
\addcontentsline{toc}{chapter}{\bibname}
\bibitem{arduino} Arduino: \emph{https://www.arduino.cc/en/Guide/Introduction}
\bibitem{visual-studio} Microsoft Visual Studio: \emph{https://visualstudio.microsoft.com/}
\bibitem{github} Github: \emph{https://github.com/}
\end{thebibliography}

% Aláírt, szkennelt nyilatkozat beillesztése a szakdolgozat végére
\includepdf{nyilatkozat.pdf}

\end{document}
